# RUBIX PLATFORM: NODE.JS_EXPRESS
# VERSION: Node_22.x|Express_4.x|5.x
# FOUNDATION: JavaScript|V8_Engine|MIT_License
# PHILOSOPHY: event_driven|non_blocking|minimal_unopinionated

==============================================================================
HISTORY
==============================================================================
2009:Ryan_Dahl>Node.js>server_side_JS|event_loop
2010:Express.js>TJ_Holowaychuk>minimal_web_framework
2011:npm_registry>package_management
2014:io.js_fork>ES6_features>merged_back
2015:Node_4.0>LTS_releases|ES6_native
2017:Node_8.0>async_await_native
2019:Node_12.0>ES_modules
2021:Node_16.0>Apple_Silicon
2023:Node_20.0>permission_model|test_runner
2024:Node_22.0>require_ESM|WebSocket_client

EXPRESS_VERSIONS
v3.x:2012>router|middleware_stack
v4.x:2014>router_module|removed_connect
v5.x:2024>async_error_handling|path_matching

CORE_MAINTAINERS_NODE
Matteo_Collina:TSC
James_Snell:TSC
Yagiz_Nizipli:performance

ARCHITECTURE:event_loop|callback|middleware

==============================================================================
EXPRESS_MIDDLEWARE_PATTERNS
==============================================================================
MIDDLEWARE_SIGNATURE
(req, res, next) => {
    // do something
    next(); // pass to next middleware
}

APPLICATION_MIDDLEWARE
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cors());
app.use(helmet());

ROUTER_MIDDLEWARE
router.use(authMiddleware);
router.get('/', handler);

ERROR_MIDDLEWARE
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(err.status || 500).json({ error: err.message });
});
!must_have_4_params
!must_be_last

ASYNC_ERROR_HANDLING
+express-async-errors:auto_catch
+wrapper_function:manual

const asyncHandler = (fn) => (req, res, next) =>
    Promise.resolve(fn(req, res, next)).catch(next);

router.get('/', asyncHandler(async (req, res) => {
    const data = await service.getData();
    res.json(data);
}));

EXPRESS_5_ASYNC
+native_async_support
+no_wrapper_needed
router.get('/', async (req, res) => {
    const data = await service.getData(); // errors auto-caught
    res.json(data);
});

ANTI_PATTERNS
-callback_hell:async_await
-not_calling_next:request_hangs
-error_swallowing:proper_error_middleware
-sync_blocking:async_operations

==============================================================================
ROUTING_PATTERNS
==============================================================================
ROUTE_ORGANIZATION
//routes/orders.js
const router = express.Router();

router.get('/', orderController.getAll);
router.get('/:id', orderController.getById);
router.post('/', validateOrder, orderController.create);
router.put('/:id', validateOrder, orderController.update);
router.delete('/:id', orderController.remove);

module.exports = router;

//app.js
app.use('/api/orders', require('./routes/orders'));
app.use('/api/customers', require('./routes/customers'));

ROUTE_PARAMETERS
router.get('/:id', (req, res) => {
    const { id } = req.params;
});

router.get('/', (req, res) => {
    const { page, limit } = req.query;
});

PARAM_MIDDLEWARE
router.param('id', async (req, res, next, id) => {
    try {
        req.order = await Order.findById(id);
        if (!req.order) return res.status(404).json({ error: 'Not found' });
        next();
    } catch (err) { next(err); }
});

ANTI_PATTERNS
-all_routes_in_app.js:modularize
-no_route_grouping:use_Router
-hardcoded_paths:constants|config

==============================================================================
CONTROLLER_PATTERNS
==============================================================================
CONTROLLER_CLASS
class OrderController {
    constructor(orderService) {
        this.orderService = orderService;
    }
    
    getAll = async (req, res, next) => {
        const orders = await this.orderService.findAll(req.query);
        res.json(orders);
    };
    
    getById = async (req, res, next) => {
        const order = await this.orderService.findById(req.params.id);
        if (!order) return res.status(404).json({ error: 'Not found' });
        res.json(order);
    };
    
    create = async (req, res, next) => {
        const order = await this.orderService.create(req.body);
        res.status(201).json(order);
    };
}

FUNCTION_CONTROLLERS
const getOrders = async (req, res) => {
    const orders = await orderService.findAll();
    res.json(orders);
};

module.exports = { getOrders, getOrder, createOrder };

ANTI_PATTERNS
-business_logic_in_controller:service_layer
-direct_db_calls:repository|service
-res.send_everywhere:consistent_json

==============================================================================
SERVICE_PATTERNS
==============================================================================
SERVICE_CLASS
class OrderService {
    constructor(orderRepository, eventEmitter) {
        this.orderRepo = orderRepository;
        this.events = eventEmitter;
    }
    
    async findAll(filters = {}) {
        return this.orderRepo.find(filters);
    }
    
    async create(data) {
        const order = await this.orderRepo.create(data);
        this.events.emit('order:created', order);
        return order;
    }
}

DEPENDENCY_INJECTION_MANUAL
//container.js
const orderRepository = new OrderRepository(db);
const orderService = new OrderService(orderRepository, eventEmitter);
const orderController = new OrderController(orderService);

module.exports = { orderController, orderService };

DI_LIBRARIES
+awilix:auto_injection
+tsyringe:TypeScript_decorators
+inversify:TypeScript_IoC

//awilix
const container = createContainer();
container.register({
    orderService: asClass(OrderService).scoped(),
    orderRepository: asClass(OrderRepository).scoped(),
});

ANTI_PATTERNS
-service_with_req_res:pure_business_logic
-singleton_with_request_state:scoped_instances
-god_service:split_by_domain

==============================================================================
REPOSITORY_PATTERNS
==============================================================================
MONGOOSE_REPOSITORY
class OrderRepository {
    constructor(model) {
        this.model = model;
    }
    
    async find(filters = {}) {
        return this.model.find(filters).lean();
    }
    
    async findById(id) {
        return this.model.findById(id).lean();
    }
    
    async create(data) {
        const doc = new this.model(data);
        return doc.save();
    }
    
    async update(id, data) {
        return this.model.findByIdAndUpdate(id, data, { new: true }).lean();
    }
}

PRISMA_REPOSITORY
class OrderRepository {
    constructor(prisma) {
        this.prisma = prisma;
    }
    
    async find(where = {}) {
        return this.prisma.order.findMany({ where, include: { items: true } });
    }
    
    async create(data) {
        return this.prisma.order.create({ data });
    }
}

ANTI_PATTERNS
-leaking_ORM:return_plain_objects
-N+1_queries:populate|include
-no_pagination:limit_offset

==============================================================================
VALIDATION_PATTERNS
==============================================================================
JOI_VALIDATION
const Joi = require('joi');

const createOrderSchema = Joi.object({
    customerId: Joi.string().required(),
    items: Joi.array().items(
        Joi.object({
            productId: Joi.string().required(),
            quantity: Joi.number().integer().min(1).required()
        })
    ).min(1).required()
});

const validate = (schema) => (req, res, next) => {
    const { error } = schema.validate(req.body);
    if (error) return res.status(400).json({ error: error.details[0].message });
    next();
};

router.post('/', validate(createOrderSchema), controller.create);

ZOD_VALIDATION
const { z } = require('zod');

const createOrderSchema = z.object({
    customerId: z.string().uuid(),
    items: z.array(z.object({
        productId: z.string().uuid(),
        quantity: z.number().int().positive()
    })).nonempty()
});

EXPRESS_VALIDATOR
const { body, validationResult } = require('express-validator');

router.post('/',
    body('email').isEmail(),
    body('password').isLength({ min: 6 }),
    (req, res, next) => {
        const errors = validationResult(req);
        if (!errors.isEmpty()) return res.status(400).json({ errors: errors.array() });
        next();
    },
    controller.create
);

ANTI_PATTERNS
-trusting_req.body:always_validate
-validation_in_controller:middleware
-no_sanitization:escape_input

==============================================================================
ERROR_HANDLING_PATTERNS
==============================================================================
CUSTOM_ERROR_CLASSES
class AppError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.statusCode = statusCode;
        this.isOperational = true;
    }
}

class NotFoundError extends AppError {
    constructor(resource = 'Resource') {
        super(`${resource} not found`, 404);
    }
}

class ValidationError extends AppError {
    constructor(message) {
        super(message, 400);
    }
}

CENTRALIZED_ERROR_HANDLER
const errorHandler = (err, req, res, next) => {
    console.error(err);
    
    if (err.isOperational) {
        return res.status(err.statusCode).json({
            status: 'error',
            message: err.message
        });
    }
    
    // Programming error - don't leak details
    res.status(500).json({
        status: 'error',
        message: 'Something went wrong'
    });
};

app.use(errorHandler);

ANTI_PATTERNS
-swallowing_errors:log_and_respond
-leaking_stack_traces:production_check
-generic_500_always:proper_status_codes

==============================================================================
ASYNC_PATTERNS
==============================================================================
PROMISE_ALL_PARALLEL
const [orders, customers] = await Promise.all([
    orderService.findAll(),
    customerService.findAll()
]);

PROMISE_ALLSETTLED
const results = await Promise.allSettled([
    fetchFromApi1(),
    fetchFromApi2()
]);
// handle both fulfilled and rejected

ASYNC_ITERATION
for await (const chunk of stream) {
    process(chunk);
}

EVENT_EMITTER_PATTERN
const EventEmitter = require('events');
const orderEvents = new EventEmitter();

orderEvents.on('created', async (order) => {
    await sendConfirmationEmail(order);
    await updateInventory(order);
});

// In service
orderEvents.emit('created', order);

ANTI_PATTERNS
-callback_hell:async_await
-unhandled_rejection:process.on('unhandledRejection')
-sequential_when_parallel:Promise.all
-blocking_event_loop:worker_threads

==============================================================================
AUTHENTICATION_PATTERNS
==============================================================================
JWT_AUTH
const jwt = require('jsonwebtoken');

const generateToken = (user) => {
    return jwt.sign({ id: user.id, role: user.role }, process.env.JWT_SECRET, {
        expiresIn: '1d'
    });
};

const authMiddleware = async (req, res, next) => {
    const token = req.headers.authorization?.split(' ')[1];
    if (!token) return res.status(401).json({ error: 'No token' });
    
    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        req.user = decoded;
        next();
    } catch (err) {
        res.status(401).json({ error: 'Invalid token' });
    }
};

PASSPORT_JS
const passport = require('passport');
const JwtStrategy = require('passport-jwt').Strategy;

passport.use(new JwtStrategy(opts, async (payload, done) => {
    const user = await User.findById(payload.id);
    return done(null, user || false);
}));

app.use(passport.initialize());
router.get('/protected', passport.authenticate('jwt', { session: false }), handler);

ANTI_PATTERNS
-jwt_in_localStorage:httpOnly_cookies
-no_token_expiry:always_expire
-secrets_in_code:env_vars

==============================================================================
SECURITY_PATTERNS
==============================================================================
HELMET
const helmet = require('helmet');
app.use(helmet());

RATE_LIMITING
const rateLimit = require('express-rate-limit');
app.use(rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 100
}));

CORS
const cors = require('cors');
app.use(cors({
    origin: ['https://myapp.com'],
    credentials: true
}));

INPUT_SANITIZATION
const mongoSanitize = require('express-mongo-sanitize');
app.use(mongoSanitize());

const xss = require('xss-clean');
app.use(xss());

ANTI_PATTERNS
-no_helmet:security_headers
-permissive_CORS:restrict_origins
-trusting_user_input:sanitize
-no_rate_limiting:DDoS_risk

==============================================================================
TESTING_PATTERNS
==============================================================================
UNIT_TESTS_JEST
describe('OrderService', () => {
    let orderService;
    let mockRepo;
    
    beforeEach(() => {
        mockRepo = { find: jest.fn(), create: jest.fn() };
        orderService = new OrderService(mockRepo);
    });
    
    it('should return all orders', async () => {
        mockRepo.find.mockResolvedValue([{ id: 1 }]);
        const result = await orderService.findAll();
        expect(result).toHaveLength(1);
        expect(mockRepo.find).toHaveBeenCalled();
    });
});

INTEGRATION_TESTS_SUPERTEST
const request = require('supertest');
const app = require('../app');

describe('GET /api/orders', () => {
    it('should return orders', async () => {
        const res = await request(app)
            .get('/api/orders')
            .set('Authorization', `Bearer ${token}`)
            .expect(200);
        
        expect(res.body).toBeInstanceOf(Array);
    });
});

MOCKING
jest.mock('../services/orderService');
const orderService = require('../services/orderService');
orderService.findAll.mockResolvedValue([]);

ANTI_PATTERNS
-testing_framework_not_app
-no_mocking:isolation
-no_integration_tests:API_coverage

==============================================================================
PROJECT_STRUCTURE
==============================================================================
STANDARD
src/
    config/
    controllers/
    middleware/
    models/
    routes/
    services/
    utils/
    app.js
    server.js

FEATURE_BASED
src/
    features/
        orders/
            order.model.js
            order.service.js
            order.controller.js
            order.routes.js
            order.validation.js
        customers/
    common/
        middleware/
        utils/

CLEAN_ARCHITECTURE
src/
    domain/
        entities/
        repositories/
    application/
        use-cases/
        services/
    infrastructure/
        db/
        external/
    interfaces/
        http/
        cli/

==============================================================================
PACKAGES_ESSENTIAL
==============================================================================
express:framework
helmet:security
cors:cross_origin
morgan:logging
joi|zod:validation
mongoose|prisma|sequelize:ORM
jsonwebtoken:auth
bcrypt:password_hashing
winston|pino:logging
jest|mocha:testing
supertest:HTTP_testing
dotenv:env_config
express-rate-limit:throttling

==============================================================================
TYPESCRIPT_PATTERNS
==============================================================================
TYPED_REQUEST
interface TypedRequest<T> extends express.Request {
    body: T;
}

const createOrder = async (
    req: TypedRequest<CreateOrderDto>,
    res: express.Response
) => {
    const order = await orderService.create(req.body);
    res.status(201).json(order);
};

TYPED_RESPONSE
interface ApiResponse<T> {
    data: T;
    meta?: { total: number; page: number };
}

res.json({ data: orders, meta: { total, page } } as ApiResponse<Order[]>);

==============================================================================
COMMON_SMELLS
==============================================================================
SMELL                    | DETECTION                        | FIX
------------------------|----------------------------------|------------------
Callback_Hell           | nested_callbacks                 | async_await
No_Error_Middleware     | try_catch_everywhere             | centralized_handler
Fat_Controller          | business_logic_in_route          | service_layer
God_File                | app.js_1000+LOC                  | modularize
No_Validation           | trusting_req.body                | joi|zod
Sync_Blocking           | fs.readFileSync_in_request       | async_versions
No_Env_Config           | hardcoded_secrets                | dotenv
Missing_Auth            | no_middleware_protection         | auth_middleware
N+1_Queries             | loop_with_db_calls               | batch|include
No_Rate_Limit           | unlimited_requests               | express-rate-limit

# RUBIX LANGUAGE: PYTHON
# VERSION: 3.12+
# FOUNDATION: Guido_van_Rossum|PSF|Open_Source
# PHILOSOPHY: readability|explicit_over_implicit|batteries_included

==============================================================================
HISTORY
==============================================================================
1991:Guido_van_Rossum>Python_0.9
2000:Python_2.0>list_comprehensions|GC
2008:Python_3.0>breaking_changes|unicode_default
2015:Python_3.5>async_await|type_hints
2018:Python_3.7>dataclasses|asyncio_improvements
2020:Python_3.9>dict_union|type_hinting_generics
2021:Python_3.10>pattern_matching|better_errors
2022:Python_3.11>faster|exception_groups
2023:Python_3.12>f-string_improvements|type_parameter_syntax
2024:Python_3.13>JIT_compiler|free_threading_experimental

KEY_PEPS
PEP_8:style_guide
PEP_20:Zen_of_Python
PEP_484:type_hints
PEP_557:dataclasses
PEP_634:pattern_matching
PEP_695:type_parameter_syntax

==============================================================================
PROJECT_SETUP
==============================================================================
PROJECT_STRUCTURE
myproject/
  src/
    myproject/
      __init__.py
      main.py
      models/
      services/
      utils/
  tests/
    __init__.py
    test_main.py
  pyproject.toml
  README.md
  .gitignore

PYPROJECT_TOML
[project]
name = "myproject"
version = "0.1.0"
description = "My Python project"
readme = "README.md"
requires-python = ">=3.12"
dependencies = [
    "httpx>=0.25.0",
    "pydantic>=2.0.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0.0",
    "ruff>=0.1.0",
    "mypy>=1.0.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.ruff]
target-version = "py312"
line-length = 100
select = ["E", "F", "I", "B", "UP"]

[tool.mypy]
python_version = "3.12"
strict = true

[tool.pytest.ini_options]
testpaths = ["tests"]
pythonpath = ["src"]

VIRTUAL_ENVIRONMENTS
# venv (built-in)
python -m venv .venv
source .venv/bin/activate  # Unix
.venv\Scripts\activate     # Windows

# uv (fast, recommended)
uv venv
uv pip install -r requirements.txt
uv pip install -e ".[dev]"

# poetry
poetry init
poetry install
poetry add httpx

PACKAGE_MANAGERS
pip:default|slow
uv:fast|rust_based|recommended
poetry:dependency_management|lockfile
pdm:PEP_582_support
pipenv:legacy

==============================================================================
TYPE_HINTS
==============================================================================
BASIC_TYPES
def greet(name: str) -> str:
    return f"Hello, {name}"

def process(count: int, factor: float = 1.0) -> float:
    return count * factor

age: int = 30
name: str = "John"
active: bool = True
scores: list[int] = [1, 2, 3]
config: dict[str, int] = {"a": 1}

OPTIONAL_UNION
from typing import Optional

def find_user(id: int) -> Optional[User]:
    return None  # or User instance

# Union syntax (3.10+)
def process(value: int | str | None) -> str:
    ...

# Old Union syntax
from typing import Union
def process(value: Union[int, str, None]) -> str:
    ...

COLLECTIONS
from typing import Sequence, Mapping, Iterable

def process_items(items: list[str]) -> None: ...
def lookup(data: dict[str, int]) -> int: ...
def read_only(items: Sequence[str]) -> None: ...
def any_mapping(data: Mapping[str, int]) -> None: ...
def iterate(items: Iterable[int]) -> None: ...

# Tuple
point: tuple[int, int] = (1, 2)
variable: tuple[int, ...] = (1, 2, 3, 4)

CALLABLE
from typing import Callable

Handler = Callable[[int, str], bool]

def register(handler: Callable[[str], None]) -> None: ...
def apply(func: Callable[..., int]) -> int: ...

GENERICS_MODERN_3_12+
def first[T](items: list[T]) -> T | None:
    return items[0] if items else None

class Stack[T]:
    def __init__(self) -> None:
        self._items: list[T] = []
    
    def push(self, item: T) -> None:
        self._items.append(item)
    
    def pop(self) -> T:
        return self._items.pop()

# Constrained
def compare[T: (int, float)](a: T, b: T) -> T:
    return max(a, b)

GENERICS_LEGACY
from typing import TypeVar, Generic

T = TypeVar('T')

def first(items: list[T]) -> T | None:
    return items[0] if items else None

class Stack(Generic[T]):
    def __init__(self) -> None:
        self._items: list[T] = []

TYPEDDICT
from typing import TypedDict, Required, NotRequired

class UserDict(TypedDict):
    name: str
    email: str
    age: NotRequired[int]

# Usage
user: UserDict = {"name": "John", "email": "john@example.com"}

LITERAL_FINAL
from typing import Literal, Final

Mode = Literal["read", "write", "append"]

def open_file(path: str, mode: Mode) -> None: ...

MAX_SIZE: Final[int] = 100
# MAX_SIZE = 200  # Type error

PROTOCOL
from typing import Protocol

class Drawable(Protocol):
    def draw(self) -> None: ...

class Circle:
    def draw(self) -> None:
        print("Drawing circle")

def render(item: Drawable) -> None:
    item.draw()

render(Circle())  # Works - structural typing

==============================================================================
DATACLASSES
==============================================================================
BASIC_DATACLASS
from dataclasses import dataclass, field
from datetime import datetime

@dataclass
class User:
    name: str
    email: str
    age: int = 0
    created_at: datetime = field(default_factory=datetime.now)
    tags: list[str] = field(default_factory=list)

user = User("John", "john@example.com", 30)
print(user.name)
print(user)  # User(name='John', email='john@example.com', ...)

FROZEN_IMMUTABLE
@dataclass(frozen=True)
class Point:
    x: float
    y: float

point = Point(1.0, 2.0)
# point.x = 3.0  # Raises FrozenInstanceError

SLOTS_MEMORY_EFFICIENT
@dataclass(slots=True)
class Point:
    x: float
    y: float

POST_INIT
@dataclass
class User:
    name: str
    email: str
    
    def __post_init__(self):
        if not self.email:
            raise ValueError("Email required")
        self.name = self.name.strip()

KW_ONLY
@dataclass(kw_only=True)
class Config:
    host: str
    port: int = 8080

config = Config(host="localhost", port=3000)

FIELD_OPTIONS
from dataclasses import field

@dataclass
class User:
    id: int = field(compare=False)  # Excluded from ==
    name: str = field(repr=True)
    _cache: dict = field(default_factory=dict, repr=False, compare=False)

==============================================================================
PYDANTIC_MODELS
==============================================================================
BASIC_MODEL
from pydantic import BaseModel, Field, EmailStr
from datetime import datetime

class User(BaseModel):
    name: str
    email: EmailStr
    age: int = Field(ge=0, le=150)
    created_at: datetime = Field(default_factory=datetime.now)
    tags: list[str] = Field(default_factory=list)

# Validation on creation
user = User(name="John", email="john@example.com", age=30)

# From dict
user = User.model_validate({"name": "John", "email": "john@example.com", "age": 30})

# To dict
data = user.model_dump()
json_str = user.model_dump_json()

VALIDATORS
from pydantic import BaseModel, field_validator, model_validator

class User(BaseModel):
    name: str
    email: str
    password: str
    password_confirm: str
    
    @field_validator('name')
    @classmethod
    def name_must_not_be_empty(cls, v: str) -> str:
        if not v.strip():
            raise ValueError('Name cannot be empty')
        return v.strip()
    
    @model_validator(mode='after')
    def passwords_match(self) -> 'User':
        if self.password != self.password_confirm:
            raise ValueError('Passwords do not match')
        return self

SETTINGS
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    database_url: str
    api_key: str
    debug: bool = False
    
    model_config = {
        'env_file': '.env',
        'env_file_encoding': 'utf-8',
    }

settings = Settings()

==============================================================================
PATTERN_MATCHING_3_10+
==============================================================================
BASIC_MATCH
def http_status(status: int) -> str:
    match status:
        case 200:
            return "OK"
        case 404:
            return "Not Found"
        case 500:
            return "Server Error"
        case _:
            return "Unknown"

PATTERN_TYPES
def process(value):
    match value:
        # Literal patterns
        case 0:
            return "zero"
        case True:
            return "true"
        
        # Capture patterns
        case x:
            return f"captured {x}"

def process_sequence(data):
    match data:
        # Sequence patterns
        case []:
            return "empty"
        case [x]:
            return f"single: {x}"
        case [x, y]:
            return f"pair: {x}, {y}"
        case [first, *rest]:
            return f"first: {first}, rest: {rest}"

def process_dict(data):
    match data:
        # Mapping patterns
        case {"type": "user", "name": name}:
            return f"User: {name}"
        case {"type": "admin", "name": name, **rest}:
            return f"Admin: {name}, extra: {rest}"

CLASS_PATTERNS
@dataclass
class Point:
    x: float
    y: float

def describe_point(point):
    match point:
        case Point(x=0, y=0):
            return "origin"
        case Point(x=0, y=y):
            return f"on y-axis at {y}"
        case Point(x=x, y=0):
            return f"on x-axis at {x}"
        case Point(x=x, y=y):
            return f"point at ({x}, {y})"

GUARDS
def categorize(value):
    match value:
        case int(n) if n < 0:
            return "negative"
        case int(n) if n == 0:
            return "zero"
        case int(n):
            return "positive"
        case str(s) if len(s) > 10:
            return "long string"
        case str():
            return "short string"

OR_PATTERNS
def is_weekend(day: str) -> bool:
    match day.lower():
        case "saturday" | "sunday":
            return True
        case _:
            return False

==============================================================================
ASYNC_PATTERNS
==============================================================================
ASYNC_BASICS
import asyncio

async def fetch_data(url: str) -> dict:
    # Simulated async operation
    await asyncio.sleep(1)
    return {"url": url, "data": "..."}

async def main():
    result = await fetch_data("https://api.example.com")
    print(result)

asyncio.run(main())

CONCURRENT_TASKS
async def main():
    # Run concurrently
    results = await asyncio.gather(
        fetch_data("url1"),
        fetch_data("url2"),
        fetch_data("url3"),
    )
    
    # With exception handling
    results = await asyncio.gather(
        fetch_data("url1"),
        fetch_data("url2"),
        return_exceptions=True,
    )

TASK_GROUPS_3_11+
async def main():
    async with asyncio.TaskGroup() as tg:
        task1 = tg.create_task(fetch_data("url1"))
        task2 = tg.create_task(fetch_data("url2"))
    
    # All tasks complete here
    print(task1.result(), task2.result())

ASYNC_CONTEXT_MANAGERS
class AsyncResource:
    async def __aenter__(self):
        await self.connect()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.disconnect()

async with AsyncResource() as resource:
    await resource.do_something()

ASYNC_ITERATORS
class AsyncCounter:
    def __init__(self, stop: int):
        self.stop = stop
        self.current = 0
    
    def __aiter__(self):
        return self
    
    async def __anext__(self):
        if self.current >= self.stop:
            raise StopAsyncIteration
        await asyncio.sleep(0.1)
        self.current += 1
        return self.current

async for num in AsyncCounter(5):
    print(num)

ASYNC_GENERATORS
async def async_range(stop: int):
    for i in range(stop):
        await asyncio.sleep(0.1)
        yield i

async for num in async_range(5):
    print(num)

HTTPX_ASYNC_CLIENT
import httpx

async def fetch_users():
    async with httpx.AsyncClient() as client:
        response = await client.get("https://api.example.com/users")
        return response.json()

async def fetch_multiple():
    async with httpx.AsyncClient() as client:
        tasks = [
            client.get(f"https://api.example.com/users/{i}")
            for i in range(10)
        ]
        responses = await asyncio.gather(*tasks)
        return [r.json() for r in responses]

==============================================================================
CONTEXT_MANAGERS
==============================================================================
CLASS_BASED
class DatabaseConnection:
    def __init__(self, connection_string: str):
        self.connection_string = connection_string
        self.connection = None
    
    def __enter__(self):
        self.connection = connect(self.connection_string)
        return self.connection
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.connection.close()
        return False  # Don't suppress exceptions

with DatabaseConnection("postgres://...") as conn:
    conn.execute("SELECT * FROM users")

CONTEXTLIB
from contextlib import contextmanager

@contextmanager
def timer(name: str):
    start = time.time()
    try:
        yield
    finally:
        elapsed = time.time() - start
        print(f"{name}: {elapsed:.2f}s")

with timer("operation"):
    do_something()

ASYNC_CONTEXT_MANAGER
from contextlib import asynccontextmanager

@asynccontextmanager
async def async_timer(name: str):
    start = time.time()
    try:
        yield
    finally:
        elapsed = time.time() - start
        print(f"{name}: {elapsed:.2f}s")

SUPPRESS_EXCEPTIONS
from contextlib import suppress

with suppress(FileNotFoundError):
    os.remove("file.txt")

==============================================================================
DECORATORS
==============================================================================
BASIC_DECORATOR
from functools import wraps

def log_calls(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__}")
        result = func(*args, **kwargs)
        print(f"Finished {func.__name__}")
        return result
    return wrapper

@log_calls
def greet(name: str) -> str:
    return f"Hello, {name}"

DECORATOR_WITH_ARGS
def repeat(times: int):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(3)
def say_hello():
    print("Hello")

CLASS_DECORATOR
def singleton(cls):
    instances = {}
    @wraps(cls)
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return get_instance

@singleton
class Database:
    pass

DECORATOR_CLASS
class Retry:
    def __init__(self, max_attempts: int = 3, delay: float = 1.0):
        self.max_attempts = max_attempts
        self.delay = delay
    
    def __call__(self, func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(self.max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == self.max_attempts - 1:
                        raise
                    time.sleep(self.delay)
        return wrapper

@Retry(max_attempts=5, delay=2.0)
def unstable_operation():
    ...

==============================================================================
ITERTOOLS_PATTERNS
==============================================================================
from itertools import (
    chain, islice, cycle, repeat,
    combinations, permutations, product,
    groupby, takewhile, dropwhile,
    accumulate, starmap, filterfalse
)

# Chain iterables
combined = chain([1, 2], [3, 4], [5, 6])

# Slice iterator
first_five = islice(infinite_iterator, 5)

# Combinations and permutations
pairs = combinations([1, 2, 3], 2)      # (1,2), (1,3), (2,3)
perms = permutations([1, 2, 3], 2)      # (1,2), (1,3), (2,1), ...
cross = product([1, 2], ['a', 'b'])     # (1,'a'), (1,'b'), (2,'a'), (2,'b')

# Group by
data = [('a', 1), ('a', 2), ('b', 3)]
for key, group in groupby(data, key=lambda x: x[0]):
    print(key, list(group))

# Accumulate
running_sum = accumulate([1, 2, 3, 4])  # 1, 3, 6, 10

==============================================================================
FUNCTOOLS_PATTERNS
==============================================================================
from functools import (
    lru_cache, cache, cached_property,
    partial, reduce, singledispatch
)

# Memoization
@lru_cache(maxsize=128)
def fibonacci(n: int) -> int:
    if n < 2:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

@cache  # Unlimited cache (3.9+)
def expensive_computation(x: int) -> int:
    return x ** 2

# Cached property
class DataProcessor:
    @cached_property
    def processed_data(self):
        return expensive_computation()

# Partial application
def power(base, exponent):
    return base ** exponent

square = partial(power, exponent=2)
cube = partial(power, exponent=3)

# Single dispatch (function overloading)
@singledispatch
def process(arg):
    raise NotImplementedError(f"Cannot process {type(arg)}")

@process.register
def _(arg: int):
    return arg * 2

@process.register
def _(arg: str):
    return arg.upper()

==============================================================================
COLLECTIONS_MODULE
==============================================================================
from collections import (
    defaultdict, Counter, deque,
    namedtuple, OrderedDict, ChainMap
)

# DefaultDict
word_counts = defaultdict(int)
for word in words:
    word_counts[word] += 1

grouped = defaultdict(list)
for item in items:
    grouped[item.category].append(item)

# Counter
counts = Counter(['a', 'b', 'a', 'c', 'a', 'b'])
counts.most_common(2)  # [('a', 3), ('b', 2)]

# Deque (double-ended queue)
dq = deque(maxlen=100)
dq.append(item)       # Right
dq.appendleft(item)   # Left
dq.pop()              # Right
dq.popleft()          # Left

# Named tuple
Point = namedtuple('Point', ['x', 'y'])
p = Point(1, 2)
print(p.x, p.y)

==============================================================================
PATH_AND_FILE_OPERATIONS
==============================================================================
from pathlib import Path

# Path creation
path = Path("dir/subdir/file.txt")
path = Path.cwd() / "data" / "file.txt"
path = Path.home() / ".config"

# Path operations
path.exists()
path.is_file()
path.is_dir()
path.name          # file.txt
path.stem          # file
path.suffix        # .txt
path.parent        # dir/subdir
path.parts         # ('dir', 'subdir', 'file.txt')

# Read/write
content = path.read_text()
path.write_text("content")
data = path.read_bytes()
path.write_bytes(data)

# Directory operations
path.mkdir(parents=True, exist_ok=True)
path.rmdir()
path.unlink()  # Delete file

# Glob
for py_file in Path(".").glob("**/*.py"):
    print(py_file)

# Iterate directory
for item in path.iterdir():
    print(item)

==============================================================================
TESTING_PYTEST
==============================================================================
BASIC_TESTS
import pytest

def test_addition():
    assert 1 + 1 == 2

def test_string_upper():
    assert "hello".upper() == "HELLO"

def test_exception():
    with pytest.raises(ValueError):
        int("not a number")

def test_exception_message():
    with pytest.raises(ValueError, match="invalid literal"):
        int("not a number")

FIXTURES
@pytest.fixture
def sample_user():
    return User(name="John", email="john@example.com")

@pytest.fixture
def db_session():
    session = create_session()
    yield session
    session.rollback()

def test_user_name(sample_user):
    assert sample_user.name == "John"

PARAMETRIZE
@pytest.mark.parametrize("input,expected", [
    (1, 2),
    (2, 4),
    (3, 6),
])
def test_double(input, expected):
    assert input * 2 == expected

@pytest.mark.parametrize("a,b,expected", [
    (1, 2, 3),
    (0, 0, 0),
    (-1, 1, 0),
])
def test_add(a, b, expected):
    assert a + b == expected

ASYNC_TESTS
import pytest

@pytest.mark.asyncio
async def test_async_function():
    result = await async_fetch_data()
    assert result is not None

MOCKING
from unittest.mock import Mock, patch, MagicMock

def test_with_mock():
    mock_api = Mock()
    mock_api.fetch.return_value = {"name": "John"}
    
    result = process_user(mock_api)
    
    mock_api.fetch.assert_called_once()

@patch("mymodule.external_api")
def test_with_patch(mock_api):
    mock_api.return_value = {"data": "mocked"}
    result = function_under_test()
    assert result == "mocked"

==============================================================================
COMMON_SMELLS
==============================================================================
SMELL                    | DETECTION                        | FIX
------------------------|----------------------------------|------------------
Mutable_Default_Arg     | def f(x=[]):                     | def f(x=None):
Bare_Except             | except:                          | except Exception:
No_Type_Hints           | def f(x, y):                     | def f(x: int, y: str):
String_Concatenation    | s = s + "more"                   | use_f-strings|join
Global_Variables        | global x                         | pass_as_parameter
No_Context_Manager      | f = open(); f.close()            | with open() as f:
Import_Star             | from x import *                  | explicit_imports
Nested_Try              | try_inside_try                   | refactor|flatten
No_Main_Guard           | code_at_module_level             | if __name__ == "__main__":
Dict_Get_KeyError       | dict[key]                        | dict.get(key, default)

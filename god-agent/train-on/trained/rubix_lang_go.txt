# RUBIX LANGUAGE: GO
# VERSION: 1.22+
# FOUNDATION: Google|Rob_Pike|Ken_Thompson|Robert_Griesemer
# PHILOSOPHY: simplicity|fast_compilation|built_in_concurrency

==============================================================================
HISTORY
==============================================================================
2009:Google>announced>Pike|Thompson|Griesemer
2012:Go_1.0>stable|compatibility_promise
2015:Go_1.5>self_hosted|GC_improvements
2018:Go_1.11>modules|versioned_dependencies
2022:Go_1.18>generics|fuzzing
2023:Go_1.21>min|max|clear|slog
2024:Go_1.22>for_range_integer|enhanced_routing

WHY_GO
+simple:25_keywords|easy_to_learn
+fast_compilation:seconds_not_minutes
+static_binary:single_executable|no_dependencies
+concurrency:goroutines|channels|built_in
+garbage_collected:automatic_memory
+strong_stdlib:http|json|crypto|testing

PHILOSOPHY
+explicit_over_implicit
+composition_over_inheritance
+errors_are_values
+simplicity_over_cleverness

==============================================================================
PROJECT_SETUP
==============================================================================
CREATE_MODULE
mkdir myproject
cd myproject
go mod init github.com/user/myproject

PROJECT_STRUCTURE
myproject/
  cmd/
    myapp/
      main.go
  internal/
    handler/
    service/
    repository/
  pkg/
    utils/
  go.mod
  go.sum
  README.md

GO_MOD
module github.com/user/myproject

go 1.22

require (
    github.com/gin-gonic/gin v1.9.1
    github.com/jmoiron/sqlx v1.3.5
)

COMMANDS
go run .                    # Run
go build .                  # Build
go test ./...               # Test all
go test -v ./...            # Verbose
go test -cover ./...        # Coverage
go fmt ./...                # Format
go vet ./...                # Static analysis
go mod tidy                 # Clean dependencies
go mod download             # Download deps
go get package@version      # Add dependency

==============================================================================
BASIC_TYPES
==============================================================================
PRIMITIVES
var s string = "hello"
var i int = 42
var i8 int8 = 127
var i16 int16 = 32767
var i32 int32 = 2147483647
var i64 int64 = 9223372036854775807
var u uint = 42
var f32 float32 = 3.14
var f64 float64 = 3.14159265359
var b bool = true
var by byte = 255           // alias for uint8
var r rune = 'A'            // alias for int32 (unicode)

SHORT_DECLARATION
s := "hello"                // Type inferred
x, y := 1, 2                // Multiple
_, err := doSomething()     // Ignore value

ZERO_VALUES
string:""
int:0
float64:0.0
bool:false
pointer:nil
slice:nil
map:nil
channel:nil

CONSTANTS
const Pi = 3.14159
const (
    StatusOK = 200
    StatusNotFound = 404
)

// Iota
const (
    Sunday = iota    // 0
    Monday           // 1
    Tuesday          // 2
)

const (
    _ = iota
    KB = 1 << (10 * iota)  // 1024
    MB                      // 1048576
    GB                      // 1073741824
)

==============================================================================
COMPOSITE_TYPES
==============================================================================
ARRAYS
var arr [5]int                    // Zero-valued
arr := [5]int{1, 2, 3, 4, 5}     // Literal
arr := [...]int{1, 2, 3}         // Size inferred
len(arr)                          // Length

SLICES
var s []int                       // nil slice
s := []int{1, 2, 3}              // Literal
s := make([]int, 5)              // Length 5, cap 5
s := make([]int, 0, 10)          // Length 0, cap 10

// Operations
s = append(s, 4, 5)              // Append
s2 := s[1:3]                     // Slice (inclusive:exclusive)
s3 := s[:2]                      // First 2
s4 := s[2:]                      // From index 2
len(s)                           // Length
cap(s)                           // Capacity
copy(dst, src)                   // Copy

MAPS
var m map[string]int             // nil map (can't write)
m := map[string]int{}            // Empty map
m := make(map[string]int)        // Empty map
m := map[string]int{             // Literal
    "one": 1,
    "two": 2,
}

// Operations
m["key"] = value                 // Set
value := m["key"]                // Get (zero if missing)
value, ok := m["key"]            // Get with existence check
delete(m, "key")                 // Delete
len(m)                           // Size

// Iteration
for key, value := range m {
    fmt.Println(key, value)
}

STRUCTS
type User struct {
    ID        int
    Name      string
    Email     string
    CreatedAt time.Time
}

// Creation
u := User{ID: 1, Name: "John", Email: "john@example.com"}
u := User{Name: "John"}          // Other fields zero-valued
u := new(User)                   // Pointer to zero-valued

// Access
u.Name = "Jane"
fmt.Println(u.Name)

// Embedding (composition)
type Admin struct {
    User                         // Embedded
    Permissions []string
}

admin := Admin{
    User: User{Name: "Admin"},
    Permissions: []string{"all"},
}
admin.Name                       // Promoted field

STRUCT_TAGS
type User struct {
    ID    int    `json:"id" db:"user_id"`
    Name  string `json:"name" validate:"required"`
    Email string `json:"email,omitempty"`
}

==============================================================================
FUNCTIONS
==============================================================================
BASIC_FUNCTION
func add(a, b int) int {
    return a + b
}

func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

NAMED_RETURNS
func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return  // Naked return
}

VARIADIC
func sum(nums ...int) int {
    total := 0
    for _, n := range nums {
        total += n
    }
    return total
}

sum(1, 2, 3)
sum(nums...)  // Spread slice

CLOSURES
func counter() func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}

c := counter()
c()  // 1
c()  // 2

DEFER
func readFile(path string) ([]byte, error) {
    f, err := os.Open(path)
    if err != nil {
        return nil, err
    }
    defer f.Close()  // Runs when function returns
    
    return io.ReadAll(f)
}

// Multiple defers - LIFO order
defer fmt.Println("first")
defer fmt.Println("second")
// Prints: second, first

==============================================================================
METHODS_AND_INTERFACES
==============================================================================
METHODS
type Rectangle struct {
    Width, Height float64
}

// Value receiver
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

// Pointer receiver (can modify)
func (r *Rectangle) Scale(factor float64) {
    r.Width *= factor
    r.Height *= factor
}

rect := Rectangle{10, 5}
rect.Area()       // 50
rect.Scale(2)     // Modifies rect
rect.Area()       // 200

WHEN_TO_USE_POINTER_RECEIVER
+need_to_modify_receiver
+large_struct:avoid_copy
+consistency:if_any_method_uses_pointer
value_receiver:small_immutable_structs

INTERFACES
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

// Composition
type ReadWriter interface {
    Reader
    Writer
}

IMPLICIT_IMPLEMENTATION
// No "implements" keyword
// Any type with matching methods satisfies interface

type MyReader struct{}

func (r MyReader) Read(p []byte) (int, error) {
    return 0, nil
}

var r Reader = MyReader{}  // Works

EMPTY_INTERFACE
var x interface{}          // Can hold any value (legacy)
var x any                  // Same, Go 1.18+ preferred

x = 42
x = "hello"
x = []int{1, 2, 3}

// Type assertion
s := x.(string)            // Panics if not string
s, ok := x.(string)        // Safe

// Type switch
switch v := x.(type) {
case int:
    fmt.Println("int:", v)
case string:
    fmt.Println("string:", v)
default:
    fmt.Println("unknown")
}

COMMON_INTERFACES
io.Reader
io.Writer
io.Closer
fmt.Stringer              // String() string
error                     // Error() string
sort.Interface            // Len, Less, Swap
http.Handler              // ServeHTTP
context.Context

==============================================================================
ERROR_HANDLING
==============================================================================
ERROR_PATTERN
func doSomething() error {
    if somethingWrong {
        return errors.New("something went wrong")
    }
    return nil
}

// Check error immediately
result, err := doSomething()
if err != nil {
    return err  // or handle
}
// Use result

CUSTOM_ERRORS
type NotFoundError struct {
    Resource string
    ID       string
}

func (e *NotFoundError) Error() string {
    return fmt.Sprintf("%s with ID %s not found", e.Resource, e.ID)
}

// Usage
return &NotFoundError{Resource: "User", ID: "123"}

WRAPPING_ERRORS
import "fmt"

// Wrap with context
if err != nil {
    return fmt.Errorf("failed to process user: %w", err)
}

// Check wrapped errors
if errors.Is(err, sql.ErrNoRows) {
    // Handle specific error
}

// Extract wrapped error
var notFound *NotFoundError
if errors.As(err, &notFound) {
    // Use notFound
}

SENTINEL_ERRORS
var ErrNotFound = errors.New("not found")
var ErrInvalidInput = errors.New("invalid input")

// Usage
if errors.Is(err, ErrNotFound) {
    // Handle
}

==============================================================================
GENERICS_1_18+
==============================================================================
GENERIC_FUNCTIONS
func Min[T constraints.Ordered](a, b T) T {
    if a < b {
        return a
    }
    return b
}

Min(1, 2)         // int
Min(1.5, 2.5)     // float64
Min("a", "b")     // string

GENERIC_TYPES
type Stack[T any] struct {
    items []T
}

func (s *Stack[T]) Push(item T) {
    s.items = append(s.items, item)
}

func (s *Stack[T]) Pop() (T, bool) {
    if len(s.items) == 0 {
        var zero T
        return zero, false
    }
    item := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return item, true
}

stack := Stack[int]{}
stack.Push(1)
stack.Push(2)
v, _ := stack.Pop()  // 2

CONSTRAINTS
import "golang.org/x/exp/constraints"

// Built-in constraints
any                        // No constraint
comparable                 // Supports == and !=
constraints.Ordered        // Supports < > <= >=
constraints.Integer        // All integer types
constraints.Float          // All float types

// Custom constraint
type Number interface {
    constraints.Integer | constraints.Float
}

func Sum[T Number](nums []T) T {
    var sum T
    for _, n := range nums {
        sum += n
    }
    return sum
}

==============================================================================
CONCURRENCY
==============================================================================
GOROUTINES
go doSomething()           // Start goroutine

go func() {
    fmt.Println("async")
}()

CHANNELS
ch := make(chan int)       // Unbuffered
ch := make(chan int, 10)   // Buffered

ch <- 42                   // Send
value := <-ch              // Receive
value, ok := <-ch          // Receive with closed check

close(ch)                  // Close channel

CHANNEL_PATTERNS
// Worker pool
func worker(jobs <-chan int, results chan<- int) {
    for job := range jobs {
        results <- process(job)
    }
}

jobs := make(chan int, 100)
results := make(chan int, 100)

for i := 0; i < 3; i++ {
    go worker(jobs, results)
}

for _, job := range jobList {
    jobs <- job
}
close(jobs)

for i := 0; i < len(jobList); i++ {
    <-results
}

SELECT
select {
case msg := <-ch1:
    fmt.Println("ch1:", msg)
case msg := <-ch2:
    fmt.Println("ch2:", msg)
case ch3 <- value:
    fmt.Println("sent to ch3")
case <-time.After(time.Second):
    fmt.Println("timeout")
default:
    fmt.Println("no activity")
}

WAIT_GROUP
var wg sync.WaitGroup

for i := 0; i < 5; i++ {
    wg.Add(1)
    go func(id int) {
        defer wg.Done()
        doWork(id)
    }(i)
}

wg.Wait()  // Block until all done

MUTEX
type SafeCounter struct {
    mu    sync.Mutex
    count int
}

func (c *SafeCounter) Inc() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.count++
}

func (c *SafeCounter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.count
}

RWMUTEX
type SafeCache struct {
    mu    sync.RWMutex
    items map[string]string
}

func (c *SafeCache) Get(key string) (string, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    v, ok := c.items[key]
    return v, ok
}

func (c *SafeCache) Set(key, value string) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.items[key] = value
}

==============================================================================
CONTEXT
==============================================================================
CONTEXT_BASICS
import "context"

// Background context (root)
ctx := context.Background()

// With cancel
ctx, cancel := context.WithCancel(context.Background())
defer cancel()

// With timeout
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

// With deadline
deadline := time.Now().Add(5 * time.Second)
ctx, cancel := context.WithDeadline(context.Background(), deadline)
defer cancel()

// With value
ctx := context.WithValue(ctx, "userID", 123)
userID := ctx.Value("userID").(int)

USING_CONTEXT
func fetchData(ctx context.Context, url string) ([]byte, error) {
    req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
    if err != nil {
        return nil, err
    }
    
    resp, err := http.DefaultClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    return io.ReadAll(resp.Body)
}

// Check cancellation
select {
case <-ctx.Done():
    return ctx.Err()
default:
    // Continue
}

==============================================================================
TESTING
==============================================================================
BASIC_TEST
// math_test.go
package math

import "testing"

func TestAdd(t *testing.T) {
    result := Add(2, 3)
    if result != 5 {
        t.Errorf("Add(2, 3) = %d; want 5", result)
    }
}

func TestAdd_Negative(t *testing.T) {
    result := Add(-1, 1)
    if result != 0 {
        t.Errorf("Add(-1, 1) = %d; want 0", result)
    }
}

TABLE_DRIVEN_TESTS
func TestAdd(t *testing.T) {
    tests := []struct {
        name     string
        a, b     int
        expected int
    }{
        {"positive", 2, 3, 5},
        {"negative", -1, 1, 0},
        {"zeros", 0, 0, 0},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := Add(tt.a, tt.b)
            if result != tt.expected {
                t.Errorf("Add(%d, %d) = %d; want %d",
                    tt.a, tt.b, result, tt.expected)
            }
        })
    }
}

TESTIFY
import (
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

func TestSomething(t *testing.T) {
    assert.Equal(t, 5, Add(2, 3))
    assert.NotNil(t, result)
    assert.NoError(t, err)
    assert.Error(t, err)
    assert.Contains(t, slice, item)
    
    // require stops on failure
    require.NotNil(t, result)
}

BENCHMARKS
func BenchmarkAdd(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Add(2, 3)
    }
}

// Run: go test -bench=.

MOCKING
type UserRepository interface {
    FindByID(id string) (*User, error)
}

type MockUserRepo struct {
    FindByIDFunc func(id string) (*User, error)
}

func (m *MockUserRepo) FindByID(id string) (*User, error) {
    return m.FindByIDFunc(id)
}

func TestService(t *testing.T) {
    mock := &MockUserRepo{
        FindByIDFunc: func(id string) (*User, error) {
            return &User{ID: id, Name: "Test"}, nil
        },
    }
    
    svc := NewService(mock)
    // Test svc
}

==============================================================================
COMMON_PATTERNS
==============================================================================
FUNCTIONAL_OPTIONS
type Server struct {
    host    string
    port    int
    timeout time.Duration
}

type Option func(*Server)

func WithHost(host string) Option {
    return func(s *Server) {
        s.host = host
    }
}

func WithPort(port int) Option {
    return func(s *Server) {
        s.port = port
    }
}

func NewServer(opts ...Option) *Server {
    s := &Server{
        host:    "localhost",
        port:    8080,
        timeout: 30 * time.Second,
    }
    for _, opt := range opts {
        opt(s)
    }
    return s
}

srv := NewServer(WithHost("0.0.0.0"), WithPort(3000))

CONSTRUCTOR_PATTERN
func NewUser(name, email string) (*User, error) {
    if name == "" {
        return nil, errors.New("name required")
    }
    if email == "" {
        return nil, errors.New("email required")
    }
    return &User{
        ID:        generateID(),
        Name:      name,
        Email:     email,
        CreatedAt: time.Now(),
    }, nil
}

==============================================================================
COMMON_SMELLS
==============================================================================
SMELL                    | DETECTION                        | FIX
------------------------|----------------------------------|------------------
Ignored_Error           | result, _ := ...                 | handle_error
Naked_Return            | return_in_long_function          | explicit_return
Global_Variables        | var_at_package_level             | dependency_injection
Interface_Pollution     | interface_with_many_methods      | small_interfaces
Pointer_Everywhere      | *Type_when_not_needed            | value_types
Goroutine_Leak          | no_way_to_stop_goroutine         | context|done_channel
Mutex_Copy              | passing_mutex_by_value           | use_pointer
Channel_Overuse         | channel_for_simple_sync          | mutex|atomic
Empty_Interface         | interface{}|any_everywhere       | specific_types
Init_Functions          | func_init()                      | explicit_initialization

# RUBIX LANGUAGE: PHP
# VERSION: 8.3+ (2024)
# HISTORY: 1995_Rasmus_Lerdorf→PHP3_1998→PHP5_OOP_2004→PHP7_Performance_2015→PHP8_JIT_2020→8.3_2023
# PHILOSOPHY: pragmatic|web_focused|forgiving|evolving

==============================================================================
SETUP_ENVIRONMENT
==============================================================================
# Installation
brew install php                    # macOS
sudo apt install php8.3             # Ubuntu
choco install php                   # Windows

# Composer (package manager)
curl -sS https://getcomposer.org/installer | php
mv composer.phar /usr/local/bin/composer

# Project structure
project/
├── composer.json
├── composer.lock
├── vendor/
├── src/
│   └── App/
├── tests/
├── public/
│   └── index.php
└── config/

# composer.json
{
    "name": "vendor/project",
    "autoload": {
        "psr-4": {
            "App\\": "src/App/"
        }
    },
    "require": {
        "php": "^8.2"
    },
    "require-dev": {
        "phpunit/phpunit": "^10.0"
    }
}

# Commands
composer install          # Install dependencies
composer require package  # Add dependency
composer update          # Update dependencies
composer dump-autoload   # Regenerate autoloader

==============================================================================
BASIC_TYPES
==============================================================================
# Scalar types
$string = "Hello";
$string = 'Hello';           # No interpolation
$int = 42;
$float = 3.14;
$bool = true;
$null = null;

# Type declarations (PHP 7+)
function add(int $a, int $b): int {
    return $a + $b;
}

# Nullable types
function find(?int $id): ?User {
    return $id ? User::find($id) : null;
}

# Union types (PHP 8+)
function process(int|string $value): int|float {
    return is_string($value) ? strlen($value) : $value * 2;
}

# Intersection types (PHP 8.1+)
function handle(Countable&Iterator $collection): void {}

# Mixed type
function anything(mixed $value): mixed {
    return $value;
}

# Never type (PHP 8.1+)
function fail(): never {
    throw new Exception('Failed');
}

# Strict mode
declare(strict_types=1);

==============================================================================
STRINGS
==============================================================================
# Interpolation
$name = "John";
echo "Hello, $name";
echo "Hello, {$name}";

# Heredoc
$html = <<<HTML
<div>
    <h1>$name</h1>
</div>
HTML;

# Nowdoc (no interpolation)
$text = <<<'TEXT'
No $interpolation here
TEXT;

# String functions
strlen($str);
substr($str, 0, 5);
str_replace('old', 'new', $str);
explode(',', $str);              # Split to array
implode(',', $array);            # Join array
trim($str);
strtoupper($str);
strtolower($str);
sprintf("Hello, %s", $name);
str_contains($str, 'needle');    # PHP 8+
str_starts_with($str, 'prefix'); # PHP 8+
str_ends_with($str, 'suffix');   # PHP 8+

==============================================================================
ARRAYS
==============================================================================
# Indexed array
$numbers = [1, 2, 3, 4, 5];
$numbers[] = 6;                   # Append

# Associative array
$user = [
    'name' => 'John',
    'email' => 'john@example.com',
    'age' => 30,
];

# Access
$name = $user['name'];
$name = $user['name'] ?? 'default';  # Null coalescing

# Array functions
count($array);
array_push($array, $item);
array_pop($array);
array_shift($array);              # Remove first
array_unshift($array, $item);     # Add to beginning
array_merge($array1, $array2);
array_keys($array);
array_values($array);
array_filter($array, fn($x) => $x > 0);
array_map(fn($x) => $x * 2, $array);
array_reduce($array, fn($carry, $item) => $carry + $item, 0);
in_array($needle, $array);
array_key_exists('key', $array);
array_unique($array);
array_reverse($array);
sort($array);                     # Modifies in place
usort($array, fn($a, $b) => $a <=> $b);

# Spread operator (PHP 7.4+)
$combined = [...$array1, ...$array2];
$copy = [...$array];

# Destructuring
[$first, $second] = $array;
['name' => $name, 'email' => $email] = $user;

==============================================================================
CONTROL_FLOW
==============================================================================
# If/else
if ($condition) {
    // ...
} elseif ($other) {
    // ...
} else {
    // ...
}

# Ternary
$result = $condition ? 'yes' : 'no';

# Null coalescing
$value = $nullable ?? 'default';
$user['name'] ??= 'Anonymous';   # Assign if null

# Nullsafe operator (PHP 8+)
$name = $user?->getProfile()?->getName();

# Match expression (PHP 8+)
$result = match($status) {
    'active' => 'User is active',
    'pending', 'review' => 'User is waiting',
    default => 'Unknown status',
};

# Switch
switch ($value) {
    case 1:
        // ...
        break;
    case 2:
        // ...
        break;
    default:
        // ...
}

# Loops
for ($i = 0; $i < 10; $i++) {
    echo $i;
}

foreach ($users as $user) {
    echo $user['name'];
}

foreach ($users as $key => $user) {
    echo "$key: {$user['name']}";
}

while ($condition) {
    // ...
}

do {
    // ...
} while ($condition);

==============================================================================
FUNCTIONS
==============================================================================
# Basic function
function greet(string $name): string {
    return "Hello, $name";
}

# Default parameters
function greet(string $name = 'World'): string {
    return "Hello, $name";
}

# Named arguments (PHP 8+)
function createUser(string $name, string $email, int $age = 0): User {
    // ...
}
createUser(name: 'John', email: 'john@example.com');
createUser(email: 'john@example.com', name: 'John');  # Any order

# Variadic functions
function sum(int ...$numbers): int {
    return array_sum($numbers);
}
sum(1, 2, 3, 4, 5);

# First-class callables (PHP 8.1+)
$fn = strlen(...);
$method = $object->method(...);

# Arrow functions (PHP 7.4+)
$double = fn($x) => $x * 2;
$add = fn($x, $y) => $x + $y;

# Closures
$multiplier = 2;
$multiply = function($x) use ($multiplier) {
    return $x * $multiplier;
};

# Closure with reference
$counter = 0;
$increment = function() use (&$counter) {
    $counter++;
};

==============================================================================
CLASSES_OOP
==============================================================================
# Class definition
class User {
    // Properties
    public string $name;
    private string $email;
    protected int $age;
    
    // Constructor
    public function __construct(string $name, string $email) {
        $this->name = $name;
        $this->email = $email;
    }
    
    // Methods
    public function getEmail(): string {
        return $this->email;
    }
    
    public function setEmail(string $email): void {
        $this->email = $email;
    }
    
    // Static
    public static function create(array $data): self {
        return new self($data['name'], $data['email']);
    }
}

# Constructor promotion (PHP 8+)
class User {
    public function __construct(
        public string $name,
        private string $email,
        protected int $age = 0,
    ) {}
}

# Readonly properties (PHP 8.1+)
class User {
    public function __construct(
        public readonly string $id,
        public string $name,
    ) {}
}

# Readonly classes (PHP 8.2+)
readonly class Point {
    public function __construct(
        public float $x,
        public float $y,
    ) {}
}

# Inheritance
class Admin extends User {
    public function __construct(
        string $name,
        string $email,
        public array $permissions = [],
    ) {
        parent::__construct($name, $email);
    }
    
    public function hasPermission(string $permission): bool {
        return in_array($permission, $this->permissions);
    }
}

# Abstract classes
abstract class Shape {
    abstract public function area(): float;
    
    public function describe(): string {
        return "A shape with area: " . $this->area();
    }
}

class Circle extends Shape {
    public function __construct(private float $radius) {}
    
    public function area(): float {
        return pi() * $this->radius ** 2;
    }
}

# Final
final class CannotExtend {}

class Base {
    final public function cannotOverride(): void {}
}

==============================================================================
INTERFACES_TRAITS
==============================================================================
# Interface
interface Renderable {
    public function render(): string;
}

interface Jsonable {
    public function toJson(): string;
}

# Implementation
class User implements Renderable, Jsonable {
    public function render(): string {
        return "<div>{$this->name}</div>";
    }
    
    public function toJson(): string {
        return json_encode(['name' => $this->name]);
    }
}

# Traits
trait Timestamps {
    private ?DateTime $createdAt = null;
    private ?DateTime $updatedAt = null;
    
    public function setCreatedAt(): void {
        $this->createdAt = new DateTime();
    }
    
    public function setUpdatedAt(): void {
        $this->updatedAt = new DateTime();
    }
}

trait SoftDeletes {
    private ?DateTime $deletedAt = null;
    
    public function delete(): void {
        $this->deletedAt = new DateTime();
    }
    
    public function isDeleted(): bool {
        return $this->deletedAt !== null;
    }
}

class Post {
    use Timestamps, SoftDeletes;
    
    public function __construct(public string $title) {
        $this->setCreatedAt();
    }
}

# Trait conflict resolution
class MyClass {
    use TraitA, TraitB {
        TraitA::method insteadof TraitB;
        TraitB::method as methodB;
    }
}

==============================================================================
ENUMS_PHP81
==============================================================================
# Basic enum
enum Status {
    case Pending;
    case Active;
    case Archived;
}

$status = Status::Active;

if ($status === Status::Active) {
    echo "Active";
}

# Backed enum
enum Status: string {
    case Pending = 'pending';
    case Active = 'active';
    case Archived = 'archived';
    
    public function label(): string {
        return match($this) {
            self::Pending => 'Waiting',
            self::Active => 'Live',
            self::Archived => 'Old',
        };
    }
}

$status = Status::from('active');        # Throws on invalid
$status = Status::tryFrom('invalid');    # Returns null
$value = Status::Active->value;          # 'active'
$cases = Status::cases();                # All cases

# Int backed
enum Priority: int {
    case Low = 1;
    case Medium = 2;
    case High = 3;
}

==============================================================================
ERROR_HANDLING
==============================================================================
# Try-catch
try {
    $result = riskyOperation();
} catch (InvalidArgumentException $e) {
    // Handle specific exception
    log($e->getMessage());
} catch (RuntimeException|LogicException $e) {
    // Handle multiple types (PHP 8+)
} catch (Exception $e) {
    // Handle any exception
} finally {
    // Always runs
    cleanup();
}

# Throwing exceptions
function divide(int $a, int $b): float {
    if ($b === 0) {
        throw new InvalidArgumentException('Division by zero');
    }
    return $a / $b;
}

# Custom exceptions
class UserNotFoundException extends Exception {
    public function __construct(int $id) {
        parent::__construct("User not found: $id");
    }
}

throw new UserNotFoundException($id);

# Error to exception
set_error_handler(function($severity, $message, $file, $line) {
    throw new ErrorException($message, 0, $severity, $file, $line);
});

==============================================================================
ATTRIBUTES_PHP8
==============================================================================
# Using attributes
#[Attribute]
class Route {
    public function __construct(
        public string $path,
        public string $method = 'GET',
    ) {}
}

#[Attribute(Attribute::TARGET_PROPERTY)]
class Column {
    public function __construct(
        public string $name,
        public bool $nullable = false,
    ) {}
}

# Applying attributes
class UserController {
    #[Route('/users', 'GET')]
    public function index(): Response {}
    
    #[Route('/users/{id}', 'GET')]
    public function show(int $id): Response {}
    
    #[Route('/users', 'POST')]
    public function store(Request $request): Response {}
}

class User {
    #[Column('user_name')]
    public string $name;
    
    #[Column('email_address', nullable: true)]
    public ?string $email;
}

# Reading attributes via reflection
$reflection = new ReflectionClass(UserController::class);
foreach ($reflection->getMethods() as $method) {
    $attributes = $method->getAttributes(Route::class);
    foreach ($attributes as $attribute) {
        $route = $attribute->newInstance();
        echo "{$route->method} {$route->path}\n";
    }
}

==============================================================================
GENERATORS_ITERATORS
==============================================================================
# Generator
function rangeGenerator(int $start, int $end): Generator {
    for ($i = $start; $i <= $end; $i++) {
        yield $i;
    }
}

foreach (rangeGenerator(1, 1000000) as $number) {
    // Memory efficient - one at a time
}

# Yield with keys
function entries(array $data): Generator {
    foreach ($data as $key => $value) {
        yield $key => $value;
    }
}

# Generator delegation
function combined(): Generator {
    yield from [1, 2, 3];
    yield from rangeGenerator(4, 6);
}

# Iterator interface
class UserCollection implements Iterator {
    private array $users = [];
    private int $position = 0;
    
    public function current(): User { return $this->users[$this->position]; }
    public function key(): int { return $this->position; }
    public function next(): void { $this->position++; }
    public function rewind(): void { $this->position = 0; }
    public function valid(): bool { return isset($this->users[$this->position]); }
}

==============================================================================
NAMESPACES_AUTOLOADING
==============================================================================
# Namespace declaration
namespace App\Services;

class UserService {
    // ...
}

# Using classes
namespace App\Controllers;

use App\Services\UserService;
use App\Models\User;
use App\Exceptions\{NotFoundException, ValidationException};

class UserController {
    public function __construct(
        private UserService $userService,
    ) {}
}

# Aliasing
use App\Services\UserService as UserSvc;
use function App\Helpers\format_date;
use const App\Constants\MAX_USERS;

# PSR-4 autoloading (composer.json)
{
    "autoload": {
        "psr-4": {
            "App\\": "src/",
            "Tests\\": "tests/"
        }
    }
}

==============================================================================
DATETIME
==============================================================================
# DateTime
$now = new DateTime();
$date = new DateTime('2024-01-15');
$date = new DateTime('next monday');

$date->format('Y-m-d H:i:s');
$date->modify('+1 day');
$date->add(new DateInterval('P1M'));  # Add 1 month

# DateTimeImmutable (recommended)
$date = new DateTimeImmutable('2024-01-15');
$tomorrow = $date->modify('+1 day');  # Returns new instance

# Intervals and periods
$interval = new DateInterval('P1D');  # 1 day
$interval = DateInterval::createFromDateString('1 month');

$start = new DateTime('2024-01-01');
$end = new DateTime('2024-12-31');
$period = new DatePeriod($start, new DateInterval('P1M'), $end);

foreach ($period as $date) {
    echo $date->format('Y-m') . "\n";
}

# Difference
$diff = $date1->diff($date2);
echo $diff->days;  # Total days
echo $diff->format('%y years, %m months');

==============================================================================
JSON
==============================================================================
# Encode
$json = json_encode($data);
$json = json_encode($data, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE);

# Decode
$data = json_decode($json);                    # Object
$data = json_decode($json, associative: true); # Array

# Error handling
$data = json_decode($json, flags: JSON_THROW_ON_ERROR);

# JsonSerializable interface
class User implements JsonSerializable {
    public function __construct(
        public string $name,
        public string $email,
        private string $password,
    ) {}
    
    public function jsonSerialize(): array {
        return [
            'name' => $this->name,
            'email' => $this->email,
            // password excluded
        ];
    }
}

echo json_encode(new User('John', 'john@example.com', 'secret'));
// {"name":"John","email":"john@example.com"}

==============================================================================
FILE_IO
==============================================================================
# Reading
$content = file_get_contents('file.txt');
$lines = file('file.txt', FILE_IGNORE_NEW_LINES);

# Writing
file_put_contents('file.txt', $content);
file_put_contents('file.txt', $content, FILE_APPEND);

# File handle
$handle = fopen('file.txt', 'r');
while (($line = fgets($handle)) !== false) {
    echo $line;
}
fclose($handle);

# CSV
$handle = fopen('data.csv', 'r');
while (($row = fgetcsv($handle)) !== false) {
    print_r($row);
}

# Directory
$files = scandir('directory');
$files = glob('*.php');
mkdir('new_dir', 0755, recursive: true);

# File info
file_exists('file.txt');
is_file('file.txt');
is_dir('directory');
filesize('file.txt');
filemtime('file.txt');

==============================================================================
COMMON_PATTERNS
==============================================================================
# Singleton
class Database {
    private static ?self $instance = null;
    
    private function __construct() {}
    
    public static function getInstance(): self {
        return self::$instance ??= new self();
    }
}

# Factory
class UserFactory {
    public static function create(array $data): User {
        return new User(
            name: $data['name'],
            email: $data['email'],
        );
    }
    
    public static function createAdmin(array $data): Admin {
        return new Admin(
            name: $data['name'],
            email: $data['email'],
            permissions: $data['permissions'] ?? [],
        );
    }
}

# Repository pattern
interface UserRepositoryInterface {
    public function find(int $id): ?User;
    public function findByEmail(string $email): ?User;
    public function save(User $user): void;
    public function delete(User $user): void;
}

class UserRepository implements UserRepositoryInterface {
    public function __construct(private PDO $pdo) {}
    
    public function find(int $id): ?User {
        $stmt = $this->pdo->prepare('SELECT * FROM users WHERE id = ?');
        $stmt->execute([$id]);
        $data = $stmt->fetch(PDO::FETCH_ASSOC);
        return $data ? User::fromArray($data) : null;
    }
}

# Service class
class UserService {
    public function __construct(
        private UserRepositoryInterface $repository,
        private EventDispatcher $events,
    ) {}
    
    public function register(array $data): User {
        $user = UserFactory::create($data);
        $this->repository->save($user);
        $this->events->dispatch(new UserRegistered($user));
        return $user;
    }
}

==============================================================================
TESTING_BASICS
==============================================================================
# PHPUnit test
use PHPUnit\Framework\TestCase;

class UserServiceTest extends TestCase {
    private UserService $service;
    
    protected function setUp(): void {
        $this->service = new UserService(new InMemoryUserRepository());
    }
    
    public function testCanCreateUser(): void {
        $user = $this->service->register([
            'name' => 'John',
            'email' => 'john@example.com',
        ]);
        
        $this->assertInstanceOf(User::class, $user);
        $this->assertEquals('John', $user->name);
    }
    
    public function testThrowsOnDuplicateEmail(): void {
        $this->expectException(DuplicateEmailException::class);
        
        $this->service->register(['name' => 'John', 'email' => 'john@example.com']);
        $this->service->register(['name' => 'Jane', 'email' => 'john@example.com']);
    }
    
    #[DataProvider('invalidEmailProvider')]
    public function testRejectsInvalidEmail(string $email): void {
        $this->expectException(ValidationException::class);
        $this->service->register(['name' => 'John', 'email' => $email]);
    }
    
    public static function invalidEmailProvider(): array {
        return [
            [''],
            ['invalid'],
            ['@example.com'],
        ];
    }
}

==============================================================================
PHP_8X_FEATURES_SUMMARY
==============================================================================
# PHP 8.0
- Named arguments: func(name: $value)
- Attributes: #[Attribute]
- Constructor promotion: public function __construct(public string $name)
- Match expression: match($x) { 1 => 'one', default => 'other' }
- Nullsafe operator: $obj?->method()
- Union types: int|string
- throw as expression

# PHP 8.1
- Enums: enum Status { case Active; }
- Readonly properties: public readonly string $id
- First-class callables: $fn = $obj->method(...)
- Intersection types: Countable&Iterator
- never return type
- Fibers (low-level async)

# PHP 8.2
- Readonly classes: readonly class Point { }
- Disjunctive Normal Form types
- null, true, false as standalone types
- Constants in traits

# PHP 8.3
- Typed class constants: public const string NAME = 'value';
- Dynamic class constant fetch: $class::{$const}
- json_validate() function
- Randomizer additions

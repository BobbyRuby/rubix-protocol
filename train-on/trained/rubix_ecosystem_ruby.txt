# RUBIX ECOSYSTEM: RUBY_LIBRARIES
# SCOPE: Frameworks|Libraries|Tools (beyond Rails - see rubix_platform_rails.txt)
# PHILOSOPHY: developer_happiness|convention_over_configuration|gems

==============================================================================
WEB_FRAMEWORKS
==============================================================================
SINATRA
desc:micro_framework|DSL
site:sinatrarb.com
use_for:APIs|microservices|simple_apps
+minimal:few_dependencies
+DSL:expressive_routing
+flexible:no_opinions

gem install sinatra

require 'sinatra'
require 'sinatra/json'

get '/' do
  'Hello, World!'
end

get '/users/:id' do
  user = User.find(params[:id])
  json user
end

post '/users' do
  data = JSON.parse(request.body.read)
  user = User.create(data)
  status 201
  json user
end

# Modular style
class MyApp < Sinatra::Base
  get '/' do
    'Hello from modular app'
  end
end

HANAMI
desc:modern_Ruby_framework|clean_architecture
site:hanamirb.org
use_for:clean_architecture|domain_driven
+clean_architecture:separation
+fast:optimized
+modern:Ruby_3_features

gem install hanami

# Action
module Web
  module Actions
    module Users
      class Show < Web::Action
        include Deps['repositories.user_repo']
        
        params do
          required(:id).filled(:integer)
        end
        
        def handle(request, response)
          user = user_repo.find(request.params[:id])
          response.body = user.to_json
        end
      end
    end
  end
end

# Repository
class UserRepo < Hanami::Repository
  def find_active
    users.where(active: true).to_a
  end
end

RODA
desc:routing_tree_framework|fast
site:roda.jeremyevans.net
use_for:APIs|performance_critical
+fast:routing_tree
+plugins:modular
+Sequel:integration

require 'roda'

class App < Roda
  plugin :json
  plugin :all_verbs
  
  route do |r|
    r.on 'users' do
      r.get Integer do |id|
        User[id].to_hash
      end
      
      r.post do
        User.create(r.params).to_hash
      end
    end
  end
end

GRAPE
desc:REST_API_framework
site:ruby-grape.org
use_for:REST_APIs|versioned_APIs
+DSL:API_focused
+versioning:built_in
+documentation:automatic

class UsersAPI < Grape::API
  version 'v1', using: :path
  format :json
  
  resource :users do
    desc 'Get all users'
    get do
      User.all
    end
    
    desc 'Get a user'
    params do
      requires :id, type: Integer
    end
    get ':id' do
      User.find(params[:id])
    end
    
    desc 'Create a user'
    params do
      requires :name, type: String
      requires :email, type: String
      optional :age, type: Integer
    end
    post do
      User.create!(declared(params))
    end
  end
end

==============================================================================
DATABASE_ORM
==============================================================================
SEQUEL
desc:database_toolkit|flexible
site:sequel.jeremyevans.net
use_for:complex_queries|performance
+flexible:raw_SQL_or_DSL
+plugins:extensive
+fast:optimized

gem install sequel pg

require 'sequel'

DB = Sequel.connect('postgres://user:pass@localhost/mydb')

# Dataset API
users = DB[:users]
users.where(active: true).order(:name).limit(10).all
users.where { age > 18 }.select(:name, :email).all
users.insert(name: 'John', email: 'john@example.com')
users.where(id: 1).update(name: 'Jane')
users.where(id: 1).delete

# Model
class User < Sequel::Model
  one_to_many :orders
  many_to_many :roles
  
  def validate
    super
    errors.add(:email, 'is required') if email.nil? || email.empty?
  end
  
  dataset_module do
    def active
      where(active: true)
    end
    
    def recent
      order(Sequel.desc(:created_at))
    end
  end
end

User.active.recent.limit(10).all
User.create(name: 'John', email: 'john@example.com')

ROM_RB
desc:Ruby_Object_Mapper|data_mapper
site:rom-rb.org
use_for:clean_architecture|complex_domains
+data_mapper:separation
+adapters:SQL|MongoDB|etc

require 'rom'

class Users < ROM::Relation[:sql]
  schema(:users, infer: true) do
    associations do
      has_many :orders
    end
  end
  
  def active
    where(active: true)
  end
end

class UserRepo < ROM::Repository[:users]
  def find(id)
    users.by_pk(id).one
  end
  
  def active_with_orders
    users.active.combine(:orders).to_a
  end
end

MONGOID
desc:MongoDB_ODM
site:mongoid.org

class User
  include Mongoid::Document
  include Mongoid::Timestamps
  
  field :name, type: String
  field :email, type: String
  field :age, type: Integer
  
  has_many :orders
  belongs_to :team
  
  validates :email, presence: true, uniqueness: true
  
  scope :active, -> { where(active: true) }
end

User.where(age: 18..65).order_by(name: :asc)

==============================================================================
HTTP_CLIENTS
==============================================================================
FARADAY
desc:HTTP_client|middleware
site:lostisland.github.io/faraday
+middleware:flexible
+adapters:multiple

gem install faraday

require 'faraday'

conn = Faraday.new(url: 'https://api.example.com') do |f|
  f.request :json
  f.response :json
  f.response :raise_error
  f.adapter Faraday.default_adapter
  
  f.headers['Authorization'] = "Bearer #{token}"
end

# GET
response = conn.get('/users/1')
user = response.body

# POST
response = conn.post('/users') do |req|
  req.body = { name: 'John', email: 'john@example.com' }
end

# With retry middleware
conn = Faraday.new do |f|
  f.request :retry, max: 3, interval: 0.5
end

HTTPARTY
desc:simple_HTTP|included_parsing
gem install httparty

require 'httparty'

class UserAPI
  include HTTParty
  base_uri 'https://api.example.com'
  headers 'Authorization' => "Bearer #{ENV['API_TOKEN']}"
  
  def self.get_user(id)
    get("/users/#{id}")
  end
  
  def self.create_user(attrs)
    post('/users', body: attrs.to_json, headers: { 'Content-Type' => 'application/json' })
  end
end

user = UserAPI.get_user(1)

TYPHOEUS
desc:parallel_HTTP|libcurl
gem install typhoeus

require 'typhoeus'

# Single request
response = Typhoeus.get('https://api.example.com/users/1')

# Parallel requests
hydra = Typhoeus::Hydra.new

requests = ids.map do |id|
  request = Typhoeus::Request.new("https://api.example.com/users/#{id}")
  hydra.queue(request)
  request
end

hydra.run

responses = requests.map(&:response)

==============================================================================
BACKGROUND_JOBS
==============================================================================
SIDEKIQ
desc:background_jobs|Redis_based
site:sidekiq.org
use_for:async_jobs|scheduled_tasks
+fast:threaded
+reliable:Redis_persistence
+dashboard:web_UI

gem install sidekiq

class HardWorker
  include Sidekiq::Worker
  sidekiq_options queue: 'default', retry: 3
  
  def perform(user_id, action)
    user = User.find(user_id)
    # Do work
  end
end

# Enqueue
HardWorker.perform_async(user.id, 'notify')

# Scheduled
HardWorker.perform_in(1.hour, user.id, 'remind')
HardWorker.perform_at(Time.now + 1.day, user.id, 'follow_up')

# Batch (Pro)
batch = Sidekiq::Batch.new
batch.on(:complete, BatchCallback)
batch.jobs do
  users.each { |u| HardWorker.perform_async(u.id, 'process') }
end

GOOD_JOB
desc:Postgres_backed_jobs|ActiveJob
gem install good_job

class NotifyUserJob < ApplicationJob
  queue_as :default
  retry_on StandardError, wait: :exponentially_longer, attempts: 5
  
  def perform(user_id)
    user = User.find(user_id)
    UserMailer.welcome(user).deliver_now
  end
end

NotifyUserJob.perform_later(user.id)
NotifyUserJob.set(wait: 1.hour).perform_later(user.id)

RESQUE
desc:Redis_backed_jobs
gem install resque

class ProcessUser
  @queue = :default
  
  def self.perform(user_id)
    user = User.find(user_id)
    # Process
  end
end

Resque.enqueue(ProcessUser, user.id)

DELAYED_JOB
desc:database_backed_jobs
user.delay.send_welcome_email
User.delay(run_at: 1.day.from_now).cleanup_inactive

==============================================================================
TESTING
==============================================================================
RSPEC
desc:BDD_testing|most_popular
site:rspec.info
+readable:natural_language
+mocking:built_in
+expectations:rich

gem install rspec

RSpec.describe UserService do
  describe '#create_user' do
    let(:repository) { instance_double(UserRepository) }
    let(:service) { described_class.new(repository) }
    
    context 'with valid attributes' do
      let(:attrs) { { name: 'John', email: 'john@example.com' } }
      
      it 'creates a user' do
        expect(repository).to receive(:save).and_return(User.new(attrs))
        
        user = service.create_user(attrs)
        
        expect(user.name).to eq('John')
        expect(user.email).to eq('john@example.com')
      end
    end
    
    context 'with invalid attributes' do
      let(:attrs) { { name: '', email: '' } }
      
      it 'raises validation error' do
        expect { service.create_user(attrs) }.to raise_error(ValidationError)
      end
    end
  end
end

# Matchers
expect(value).to eq(expected)
expect(value).to be_truthy
expect(array).to include(item)
expect(array).to contain_exactly(1, 2, 3)
expect(hash).to have_key(:name)
expect { block }.to raise_error(SomeError)
expect { block }.to change { User.count }.by(1)

MINITEST
desc:lightweight_testing|stdlib
require 'minitest/autorun'

class UserServiceTest < Minitest::Test
  def setup
    @service = UserService.new
  end
  
  def test_creates_user
    user = @service.create(name: 'John', email: 'john@example.com')
    
    assert_equal 'John', user.name
    assert_equal 'john@example.com', user.email
  end
  
  def test_raises_on_invalid_input
    assert_raises(ValidationError) do
      @service.create(name: '', email: '')
    end
  end
end

# Minitest::Spec
describe UserService do
  it 'creates user' do
    _(service.create(attrs).name).must_equal 'John'
  end
end

FACTORY_BOT
desc:test_fixtures|factories
gem install factory_bot

FactoryBot.define do
  factory :user do
    name { Faker::Name.name }
    email { Faker::Internet.email }
    
    trait :admin do
      role { 'admin' }
    end
    
    trait :with_orders do
      after(:create) do |user|
        create_list(:order, 3, user: user)
      end
    end
  end
end

# Usage
user = create(:user)
admin = create(:user, :admin)
user_with_orders = create(:user, :with_orders)
users = create_list(:user, 5)

FAKER
desc:fake_data_generation
Faker::Name.name
Faker::Internet.email
Faker::Address.city
Faker::Lorem.paragraph
Faker::Number.between(from: 1, to: 100)

VCRINSPEC
desc:HTTP_recording|playback
VCR.use_cassette('users/show') do
  response = api_client.get_user(1)
  expect(response.name).to eq('John')
end

WEBMOCK
desc:HTTP_mocking
stub_request(:get, 'https://api.example.com/users/1')
  .to_return(status: 200, body: { name: 'John' }.to_json)

==============================================================================
AUTHENTICATION
==============================================================================
DEVISE
desc:Rails_authentication|full_featured
(covered in Rails platform file)

RODAUTH
desc:authentication_framework|flexible
site:rodauth.jeremyevans.net
+flexible:any_framework
+secure:secure_defaults
+features:MFA|WebAuthn|etc

BCRYPT
desc:password_hashing
gem install bcrypt

require 'bcrypt'

# Hash password
password_hash = BCrypt::Password.create('secret')

# Verify password
password = BCrypt::Password.new(password_hash)
password == 'secret'  # true

JWT
desc:JSON_Web_Tokens
gem install jwt

require 'jwt'

# Encode
payload = { user_id: 1, exp: Time.now.to_i + 3600 }
token = JWT.encode(payload, secret, 'HS256')

# Decode
decoded = JWT.decode(token, secret, true, algorithm: 'HS256')
user_id = decoded[0]['user_id']

==============================================================================
SERIALIZATION
==============================================================================
OJ
desc:fast_JSON|optimized
gem install oj

require 'oj'

Oj.dump(object)  # To JSON
Oj.load(json)    # From JSON

# Rails mode
Oj.mimic_JSON

BLUEPRINTER
desc:fast_serializer
gem install blueprinter

class UserBlueprint < Blueprinter::Base
  identifier :id
  fields :name, :email
  
  view :detailed do
    association :orders, blueprint: OrderBlueprint
    field :created_at
  end
end

UserBlueprint.render(user)
UserBlueprint.render(user, view: :detailed)
UserBlueprint.render(users)  # Array

ALBA
desc:fast_serializer|modern
class UserResource
  include Alba::Resource
  
  attributes :id, :name, :email
  
  attribute :full_name do |user|
    "#{user.first_name} #{user.last_name}"
  end
  
  many :orders, resource: OrderResource
end

UserResource.new(user).serialize

==============================================================================
CACHING
==============================================================================
REDIS_RB
desc:Redis_client
gem install redis

require 'redis'

redis = Redis.new(url: ENV['REDIS_URL'])

redis.set('key', 'value')
redis.setex('key', 3600, 'value')  # With TTL
value = redis.get('key')
redis.del('key')

# Hash
redis.hset('user:1', 'name', 'John')
redis.hget('user:1', 'name')
redis.hgetall('user:1')

# Lists
redis.lpush('queue', 'job1')
redis.rpop('queue')

DALLI
desc:Memcached_client
gem install dalli

require 'dalli'

client = Dalli::Client.new('localhost:11211')

client.set('key', 'value', 3600)
value = client.get('key')

# Fetch with block
value = client.fetch('key', 3600) do
  expensive_computation
end

==============================================================================
UTILITIES
==============================================================================
DRY_RB
desc:toolkit_of_gems|functional
site:dry-rb.org

# dry-types
module Types
  include Dry.Types()
  
  Email = String.constrained(format: /\A[\w+\-.]+@[a-z\d\-]+(\.[a-z\d\-]+)*\.[a-z]+\z/i)
  Age = Integer.constrained(gteq: 0, lteq: 150)
end

# dry-validation
class CreateUserContract < Dry::Validation::Contract
  params do
    required(:name).filled(:string)
    required(:email).filled(Types::Email)
    optional(:age).maybe(Types::Age)
  end
  
  rule(:email) do
    key.failure('already taken') if User.exists?(email: value)
  end
end

contract = CreateUserContract.new
result = contract.call(params)
result.success?
result.errors.to_h

# dry-monads
include Dry::Monads[:result, :maybe]

def find_user(id)
  user = User.find_by(id: id)
  user ? Success(user) : Failure(:not_found)
end

find_user(1).bind { |user| Success(user.name) }

CONCURRENT_RUBY
desc:concurrency_tools
gem install concurrent-ruby

require 'concurrent'

# Future
future = Concurrent::Future.execute { expensive_operation }
future.value  # Blocks until complete

# Promise
promise = Concurrent::Promise.execute { step1 }
  .then { |result| step2(result) }
  .then { |result| step3(result) }

# Thread pool
pool = Concurrent::FixedThreadPool.new(5)
pool.post { do_work }

# Atomic
counter = Concurrent::AtomicFixnum.new(0)
counter.increment
counter.value

PUMA
desc:web_server|threaded
site:puma.io
+threaded:concurrent
+clustered:multiple_workers
+production:battle_tested

# config/puma.rb
workers ENV.fetch('WEB_CONCURRENCY', 2)
threads_count = ENV.fetch('RAILS_MAX_THREADS', 5)
threads threads_count, threads_count

preload_app!

==============================================================================
CLI
==============================================================================
THOR
desc:CLI_framework|Rails_uses
gem install thor

require 'thor'

class MyCLI < Thor
  desc 'hello NAME', 'Say hello'
  option :loud, type: :boolean, default: false
  def hello(name)
    greeting = "Hello, #{name}"
    greeting = greeting.upcase if options[:loud]
    puts greeting
  end
  
  desc 'process FILE', 'Process a file'
  option :output, aliases: '-o', required: true
  def process(file)
    # Process file
  end
end

MyCLI.start(ARGV)

TTY_TOOLKIT
desc:terminal_tools
site:ttytoolkit.org
# tty-prompt, tty-spinner, tty-table, tty-progressbar

require 'tty-prompt'
prompt = TTY::Prompt.new

name = prompt.ask('Name?')
choice = prompt.select('Choose:', %w[Option1 Option2 Option3])
confirmed = prompt.yes?('Continue?')

==============================================================================
CODE_QUALITY
==============================================================================
RUBOCOP
desc:linter|style_checker
gem install rubocop

# .rubocop.yml
AllCops:
  NewCops: enable
  TargetRubyVersion: 3.2

Style/StringLiterals:
  EnforcedStyle: single_quotes

Metrics/MethodLength:
  Max: 15

# Run
rubocop
rubocop -a  # Auto-fix

SORBET
desc:type_checker|Stripe
site:sorbet.org

# typed: strict
class User
  extend T::Sig
  
  sig { params(name: String, email: String).void }
  def initialize(name, email)
    @name = name
    @email = email
  end
  
  sig { returns(String) }
  attr_reader :name, :email
end

STEEP
desc:type_checker|RBS
# sig/user.rbs
class User
  attr_reader name: String
  attr_reader email: String
  
  def initialize: (String name, String email) -> void
end

==============================================================================
DEPENDENCY_MATRIX
==============================================================================
WEB:Sinatra|Hanami|Roda|Grape
ORM:Sequel|ROM|Mongoid|ActiveRecord
HTTP:Faraday|HTTParty|Typhoeus
JOBS:Sidekiq|GoodJob|Resque
TESTING:RSpec|Minitest|FactoryBot|Faker
AUTH:Devise|Rodauth|JWT
SERIALIZATION:Blueprinter|Alba|Oj
CACHE:Redis|Dalli
UTILITY:dry-rb|Concurrent-Ruby
CLI:Thor|TTY
QUALITY:RuboCop|Sorbet|Steep
